\chapter{Графови}

\section{Теоријске основе}
\textbf{Граф}, посматрано из угла дискретне математике, односно прецизније теорије графова, представља структуру која се састоји од скупа објеката који међу собом могу имати специфичну повезаност, односно релацију. Сами објекти који се повезују се називају \textbf{теменима \textit{(eng. vertex)}}, док су везе између тих објеката \textbf{потези, односно ивице \textit{(eng. edge)}} \cite{graph-gt-definition}. Посматрано из угла рачунарства, граф представља апстрактну структуру података која служи за само моделовање графова из математичке области теорије графова на рачунару \cite{graph-cs-definition}.

\par
Најједноставнија таксономија графова јесте на \textbf{усмерене} и \textbf{неусмерене} графове \cite{graph-taxonomy}. \textbf{Усмерени графови} су сачињени од скупа темена и скупа \textbf{усмерених потега}, такође познатих и под називом \textbf{гране \textit{(eng. arc)}} \cite{directed-graph-definition}, док се \textbf{неусмерени графови} дефинишу као уређеи пар скупа чворова и \textbf{неусмерених потега}, односно \textbf{линкова} \cite{undirected-graph-definition}. 

\par
За потег $e_i$, који спаја темена $x$ i $y$ кажемо да је \textbf{усмерен} ако важи да је $x$ директан следбеник $y$, односно $y$ директан претходник $x$, док не важи обрнуто, да је $y$ директан следбеник $x$, односно $x$ директан претходник $y$ \cite{directed-graph-definition}. Математички то можемо представити као:
$$\text{e}_i = (x, y) \neq (y, x) = e_j$$  

\par
За потег $e_p$ који спаја темена $s$ i $t$ кажемо да је \textbf{неусмерен}, ако важи да је $s$ директан следбеник $t$, односно $t$ директан претходник $s$, и да важи обрнуто, да је $t$ директан следбеник $s$, односно $s$ директан претходник $t$ \cite{undirected-graph-definition}. Математички то можемо представити као:
$$\text{e}_p = (s, t) = (t, s) = e_q$$  

\par
Уколико зађемо дубље у природу графова, можемо дефинисати и путању између два чвора у графу. \textbf{Путања} представља секвенцу или низ потега, таквих да се одредишно теме $i$-ог потега поклапа са полазним чвором $i+1$-ог потега. Ова секвенца за први потег има потег коме је полазни чвор заправо чвор од ког се започиње обилазак, док је последњи потег у секвенци, потег коме је одредишни чвор заправо чвор до ког се тражи пут. Овај низ у већини случаја је низ јединствених темена, а самим тим и низ јединствених потега \cite{graph-path}. Код неусмерених графова ће због њихове природе важити да уколико постоји пут од чвора $А$ до чвора $B$, постојаће и пут од чвора $B$ до чвора $А$, док код усмерених графова ово неће бити случај.

\par
Када говоримо о графу генерално, било који чвор графа нема ограничење у виду кардиналности скупа потега којима је повезан са осталим чворовима графа, као ни то до којих чворова може имати потеге. У таквом графу је могуће идентификовати циклусе, или петље. \textbf{Петља} представља путању у којој су почетни и одредишни чвор једнаки \cite{graph-path}. Специфична ситуација код неусмерених графова је та да уколико постоји барем један потег, аутомаtски постоји и циклус у том графу.

\par
Са друге стране, можемо дефинисати и \textbf{најкраћи пут} између два чвора у графу, односно путању са најмањом кардиналношћу од свих могућих путања између два задата чвора у графу. Јасно је да оваква путања никада неће имати циклусе \cite{graph-path}.

\par
Дакле, проналажење најкраћег пута у графу може бити јако комплексан проблем, па самим тим има и веома широк спектар решења која се прилагођавају за различите случаје. 

\section{Репрезентација графа}

\par
Математички, граф можемо представити као уређен пар два скупа $V$ и $E$ који представљају скупове чворова и потега графа $G$ респективно, односно $G(V, E)$ \cite{graph-representation}. Оваква репрезентација је математички јасна, међутим у рачунарству би била јако непрактична. Из тог разлога постоји више начина за представљање графа.

\subsection{Логичка репрезентација графа}
Узећи за пример граф $G = (V, E)$ где важи следеће:
$$ V = \{A, B, C, D, E\} \; E = \{e1, e2, e3, e4, e5, e6\} $$
$$ e1 = (A, B) \; e2 = (B, C) \; e3 = (C, D) $$
$$ e4 = (D, E) \; e5 = (E, A) \; e6 = (E, E) $$
Овај граф можемо визуелно представити (\ref{fig:directed-graph}).
\begin{figure}[!ht]
    \centering
    \tikzfig{tikzit-graphs/graph}
    \caption{\textit{Пример усмереног графа $G$}}
    \label{fig:directed-graph}
\end{figure}

\par
Уколико бисмо желели да моделујемо овако нешто у оквиру програмског језика \textit{C}, имали бисмо структуру чвора (\ref{code:graph-representation}, linije 1-5), потега (\ref{code:graph-representation}, linije 7-12) и графа (\ref{code:graph-representation}, linija 14-19).

\begin{listing}[!ht]
\inputminted{c}{kodovi/graph.c}
\caption{\textit{Репрезентација графа у \texttt{C}-у}}
\label{code:graph-representation}
\end{listing}

Структура чвора би се састојала из показивача на први потег у листи потега који полазе из тог чвора, показивачa на тип чворa, који би представљао логичког следбеника у листи свих чворова графа и једнe целобројнe променљивe која би представљала вредност/идентификатор чвора.

\par
Структура потега би садржала два показивача на структуру типа чворa, један за одредишни, други за изворишни чвор, један показивач на тип потегa, којим би се представљао логички потег следбеник тренутног потега у графу и евентуално целобројну порменљиву која би представљала тежину самог потега (уколико говоримо о тежинским графовима \cite{graph-cs-definition}).

\par
На крају, сама структура графа би садржала два показивача, један показивач на тип чвор, који представља логички почетак листе свих чворова у графу и други показивач на тип потег, који би представљао логичку листу свих потега у графу.

\par
Из овога можемо закључити да репрезентација графа може постати јако комплексна уколико кренемо логички да је имлементирамо у оквиру различитих програмских језика.

\subsection{Матрична репрезентација графа}
Над компликованим структурама је јако тешко имплементирати већ постојеће алгоритме, тако да је увек препоручљиво пребацити се на домен који је рачунару јако познат. У овом случају то су матрице (низови).

\par
Када се говоримо о матричној репрезентацији графа \cite{matrix-representation}, углавном се мисли на квадратне матрице, којима се означавају суседи, односно потези. Одавде такве матрице добијају назив \textbf{матрице суседства}, или \textbf{матрице повезаности} \cite{matrix-representation}. У зависности од кардиналности скупа потега $Е$, ове матрице могу бити ретко \cite{sparse-matrix} или густо поседнуте \cite{dense-matrix}. 

\par
Приступ за репрезентацију графа у матричном облику је одиста прост. За квадратну матрицу $А$, елементи $i$-ог реда матрице ће представљати потеге од $i$-ог темена, док ће у пресеку са $ј$-ом колоном имати вредност $1$, уколико постоји потег $е_{ij} = (v_i, v_j)$, односно вредност $0$ уколико не постоји потег између $i$-ог и $j$-ог темена. Наиме, уколико је кардиналност скупа чворова графа $G$ једнака целобројној вредности $n$ $(|V| = n)$, онда би наша квадратна матрица $A$ била димензија $n\times n$, или математички:
$$G(V, E) \land |V| = n \implies A \in M_{n \times n}$$
\[
A = [a_{ij}]_{n \times n}, \;\; a_{ij} = 
\begin{cases}
\text{1}, & if e_{ij} = (v_i, v_j) \in E\\
\text{0}, & if e_{ij} = (v_i, v_j) \notin E
\end{cases}
\]


На пример, уколико бисмо желели да граф са слике \ref{fig:directed-graph} представимо као квадратну матрицу, добили бисмо следећу матрицу суседства $А$:
\[
\begin{split}
V &= \{\, A,\, B,\, C,\, D,\, E\, \} \\
E &= \{\, e(A, B),\, e(B, C),\, e(C, D),\, e(D, E),\, e(E, E)\, \} \\
A &=
\begin{bmatrix}
e(A, A) \notin E & e(A, B) \in E & e(A, C) \notin E & e(A, D) \notin E & e(A, E) \notin E \\
e(B, A) \notin E & e(B, B) \notin E & e(B, C) \in E & e(B, D) \notin E & e(B, E) \notin E \\
e(C, A) \notin E & e(C, B) \notin E & e(C, C) \notin E & e(C, D) \in E & e(C, E) \notin E \\
e(D, A) \notin E & e(D, B) \notin E & e(D, C) \notin E & e(D, D) \notin E & e(D, E) \in E \\
e(E, A) \in E & e(E, B) \notin E & e(E, C) \notin E & e(E, D) \notin E & e(E, E) \in E \\
\end{bmatrix} \\
&=
\begin{bmatrix}
0 & 1 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 1 \\
1 & 0 & 0 & 0 & 1 \\
\end{bmatrix}
\end{split}
\]

\par
С обзиром да се ради о слабо повезаном графу \cite{graphs2}, $|E| << |V|^2$, добијамо ретко поседнуту матрицу суседства, која је препуна нула. Оваква репрезентација је сада подложна матричним алгоритмима, међутим меморијски беспотребно заузима огроман простор.

\subsection{Репрезентација графа назубљеном матрицом} \label{graph-as-sparse-matrix}
У претходом делу смо видели како изгледа представљање графа матрицом суседства. Могли смо да закључимо да за поједине случаје (слабо повезане графове), оваква репрезентација није најпогоднија, зато што имамо огроман број $0$, који нам не говори ништа специјално. Шта би се десило уколико бисмо само уклонили нуле из матрице?

За дати пример графа \ref{fig:directed-graph}, матрица суседства има следећи изглед:
$$
A =
\begin{bmatrix}
0 & 1 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 1 \\
1 & 0 & 0 & 0 & 1 \\
\end{bmatrix}
$$
Када бисмо уклонили нуле из матрице добили бисмо:
$$
A =
\begin{bmatrix}
1 \\
1 \\
1 \\
1 \\
1 & 1 \\
\end{bmatrix}
$$
Овде се сада јављају два проблема:
\begin{enumerate}
    \item Редови немају исти број колона (темена немају исти број суседа),
    \item Шта нам сад значе јединице, ако су поравнане налево?
\end{enumerate}

\par
Први проблем можемо решити линеаризацијом матрице $A$ на вектор $a$ \cite{matrix-transformations}, који је сада максималне димензије $n \times n$, где је $n = |V|$. Вектор $a$ бележи елементе $a_{ij}$ из матрице суседства $А$ који су различити од нуле, односно за које важи $e(v_i, v_j) \in E$.

\par Како бисмо могли да бележимо помераје у оквиру вектора $a$ уводимо још један вектор $d$, који ће бити димензије $n$, a чије вредности ће ићи у опсегу $[1-n^2)$. Елемент вектора $d_{i}$ ће представљати индекс у оквиру вектора $a$ од кога креће листа суседа за теме $v_i$. Математички:
$$d(i) = d(i - 1) + |E_{v_i}| \;\; \land a_0=1$$
где је
$$E_{v_i} = \{e(v_i, v_j) \; | \; \forall v_j \in V \land e(v_i, v_j) \in E\} \; \implies \; E_{v_i}\subset E$$

Oдносно сви потези из скупа $E$ који за полазни потег имају потег $v_i$. Како бисмо могли да водимо евиденцију и о томе колико укупно потега има у графу, додајемо на крај вектора $d$ елемент који представља суму $d(n) + |E_{v_n}|$, односно укупан број потега у графу. Сада је вектор $d$ димензија $n + 1$.

\par
Сада ће наши вектори $a$ и $d$ на основу матрице $A$ изгледати:
\[
\begin{split}
a &= 
\begin{bmatrix}
    1 & 1 & 1 & 1 & 1 & 1
\end{bmatrix}\\
d &=
\begin{bmatrix}
    0 & 1 & 2 & 3 & 4 & 6
\end{bmatrix}
\end{split}
\]
\par
Остало нам је само још да дефинишемо шта која вредност у вектору $а$ значи. Знамо да је вредност $d(i)$ индекс у оквиру вектора $a$ од којег почињу суседи темена $v_i$. Уколико бисмо уместо јединица заправо бележили суседе, онда би вектор $a$ имао изглед:
$$
a = 
\begin{bmatrix}
    B & C & D & E & A & E
\end{bmatrix}
$$
\par
Пресликавањем ових темена функцијом:
$$
F(v_i) = i, \; \; \forall i \in [1, \lvert V \rvert]
$$
Добијамо конични облик вектора $a$:
$$
a = 
\begin{bmatrix}
    2 & 3 & 4 & 5 & 1 & 5
\end{bmatrix}
$$
\par
Овим смо постигли, да слабо повезани граф $G$ представимо на веома једноставан начин, који је веома меморијски ефикасан и у позадини користи нозове, те је меморијски приступ максимизован.

\section{Претраживање графа}
\textbf{Претраживање графа представља} процес посећивања \textit{(eng. visit)} сваког чвора у графу где је посета генерализација неке од операција читања или модификације датог чвора \cite{graph-algorithms}. У зависности од редоследа посећивања, може се дефинисати широка таксономија алгоритама за претраживање графа.

\par
Сваки од алгоритама за претраживање графа има за циљ избегавање циклуса у графу, а специјална врста обиласка графа јесте проблем проналажења најкраћег пута (пута са најмањом ценом, уколико се ради о тежинским графовима) \cite{traveling-salesman}.

\subsection{Алгоритми обиласка графа}
Најпознатији алгоритми за обилазак графа јесу \textbf{облизак графа по дубини (\textit{eng. Depth-First Search - DFS})} \cite{graph-algorithms} и \textbf{обилазак графа по ширини (\textit{eng. Breadth-First Search - BFS})} \cite{graph-algorithms}. Идеја иза ова два алгоритма јесте да се у прослеђеном графу $G$ и са почетним чвором $v$ обиђу сви чворови који имају директне или индиректне потеге од почетног чвора и то без понављања (циклуса).

\subsubsection{Алгоритам обиласка графа по дубини}
\textbf{Претрага по дубини \textit{(eng. Depth-First Search - DFS)}} је алгоритам за прелазак преко коначног графа, односно графа са коначним бројем темена/потега \cite{graph-algorithms}. Идеја иза \textit{DFS} алгоритма јесте да се у свакој итерацији прво посети чворове потомке чвора који се обрађује, па тек онда његове суседе. Односно прелази дубину било ког одређеног пута пре него што истражи његову ширину. Стек, или као структура података, или својство рекурзије, се генерално користи приликом имплементације овог алгоритма.

\par
Алгоритам почиње са изабраним \textit{"коренским"} теменом. Затим итеративно прелази са тренутног темена на његове суседе, који су непосећени, све док више не може да пронађе непосећено теме на које би прешао са своје тренутне локације. Алгоритам се затим враћа дуж претходно посећених темена, све док не пронађе теме повезано са следећом неистраженом територијом. Затим ће наставити новом путањом као и раније, враћајући се уназад када наиђе на ћорсокак. Алгоритам се завршава тек када се врати преко првобитног \textit{"коренског"} темена из првог корака, односно одакле је кренуо. Псеудокод овог алгоритма приказан је у оквиру исечка \ref{pseudocode:algorithm-dfs-traversal-pseudo}.

\begin{figure}[!ht]
\centering
\input{kodovi/dfs-traversal-pseudo.tex}
\caption{\textit{Псеудокод - Обилазак графа по дубини}}
\label{pseudocode:algorithm-dfs-traversal-pseudo}
\end{figure}

\par
Временска комплексност алгоритма претраге графа по дубини је у најгорем случају $\mathcal{O}(|V| + |E|)$. Јасно је да је разлог овога то што сваки чвор и потег морају бити посећени барем једном. Уколико говоримо о чврсто повезаним графовима \cite{graphs2}, тада важи да је $|E| = |V|^2$, па је онда временска комплексност таквих графова у најгорем случају $\mathcal{O}(|V| + |V|^2)$. Што се просторне комплесности тиче, она је $\mathcal{O}(d)$, где је $d$ максимална дубина графа. Ово је јасно, јер тада на стек морају да се нађу сви чворови кроз које се прошло да би се стигло до најдубљег темена. Овај алгоритам је погодан када немамо предубоко стабло, као и то када нас не интересује да ли је крајњи чвор близу почетног чвора.

\subsubsection{Алгоритам обиласка графа по ширини}
\textbf{Претрага у ширину \textit{(eng. Breadth-First Search - BFS)}} је алгоритам за претрагу коначног графа \cite{graph-algorithms}. Почиње од \par{"коренског"} темена и истражује све чворове на тренутној дубини пре него што пређе на чворове на следећем нивоу дубине. Додатна меморија, обично структура података типа ред \textit{(eng. queue)}, потребна је за праћење следбенских чворова који су наишли, али још нису истражени.

\par
На пример, у шаховској завршници, машински алгоритам за шах може да изгради стабло игре од тренутне позиције применом свих могућих потеза и користи претрагу по ширини да пронађе позицију за победу белих фигура. Имплицитна стабла (као што су стабла игре или друга стабла за решавање проблема) могу бити бесконачне величине. Претрага по ширини ће гарантовано пронаћи стање решења, уколико оно постоји. Псеудокод алгоритма претраге по ширини је дат у оквиру исечка \ref{pseudocode:algorithm-bfs-traversal-pseudo}.

\begin{figure}[h!]
\centering
\input{kodovi/bfs-traversal-pseudo.tex}
\caption{\textit{Псеудокод - Обилазак графа по ширини}}
\label{pseudocode:algorithm-bfs-traversal-pseudo}
\end{figure}

\par
Временска комплексност може бити дата као $\mathcal{O}(|V| + |E|)$, с обзиром да ће у најгорем могућем случају свако теме и потег бити посећени барем једном. Битно је напоменути да кардиналност скупа потега $|E|$ може да варира између $\mathcal{O}(1)$ и $\mathcal{O}(|V|^2)$, у зависности од тога колико је граф повезан. Тако да временска комплексност алгоритма са слике \ref{pseudocode:algorithm-bfs-traversal-pseudo} у најгорем могућем случају, за чврсто повезан граф може достићи $\mathcal{O}(|V|+|V|^2)$. Што се просторне комплексности тиче, она достиже максимум са $\mathcal{O}(b^d)$, где је $b$ максимални фактор гранања, а $d$ представља максималну дубину графа. Овај алгоритам очигледно треба избегавати уколико је меморија ограничавајући фактор, као и то када желимо да тражени чвор буде најближи, односно има најмање чворова преко којих мора да се иде, почетном чвору. 