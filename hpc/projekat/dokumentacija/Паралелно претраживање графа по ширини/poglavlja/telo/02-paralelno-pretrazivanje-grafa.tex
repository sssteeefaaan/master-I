\chapter{Паралелно претраживање графа}
Претраживање података је привукло велику пажњу последњих година захваљујући расту потражње за техникама које омогућују претрагу података великих размера у важним областима као што су геномика, астрофизика и национална безбедност. Претраживање графова игра важну улогу у анализи великих скупова података у многим случајевима који у некој мери имају податаке који се доводе у међусобну релацију, јер се такви подаци често представљају у облику графова, као што су семантички графови \cite{graph-semantics}. Претрага по ширини је од посебног значаја међу различитим методама претраживања графова и користи се у многим апликацијама. Природа односа између два темена у семантичком графу, на пример, може бити одређена најкраћим путем између њих помоћу претраге по ширини \cite{parallel-graph-traversal}.

\par
Претраживање веома великих графова са милијардама темена и потега представља изазове углавном због огромног простора за претрагу који намећу овакви графови. Посебно, често је немогуће складиштити тако велике графове у радној меморији једног рачунара. Ово чини традиционалне паралелне алгоритме за претрагу по ширини засноване на \textit{PRAM}-у неупотребљивим и захтевају дистрибуиране паралелне алгоритме где се израчунавање пребацује на процесор који поседује податке. Очигледно, скалабилност дистрибуираног \textit{BFS} алгоритма за врло
велике графове постаје критично питање, будући да се потражња за локалном меморијом и међупроцесорском комуникацијом повећава како се повећава величина графа \cite{bfs-dist}. 

\par
У овом раду је анализирана скалабилна и ефикасна дистрибуирана \textit{BFS} шема која је способна да рукује графовима са милијардама темена и потега. Такође, алгоритам је имплементиран у програмском језику \textit{C} и тестиран над насумично генерисаним графовима који су представљени назубљеним матрицама.

\section{Паралелни \textit{BFS} са дистрибуираном меморијом}
У овом одељку је представљен и анализиран дистрибуирани \textit{BFS} алгоритам са једнодимензионим партиционисањем \textit{(eng. one dimentional partitioning)} \cite{bfs-dist}. Предложени алгоритам је \textit{BFS} алгоритам синхронизован по нивоима који напредује ниво по ниво, почевши од изворног чвора, где је ниво темена дефинисан као његов граф удаљености од извора. У наставку је са $P$ означен број процесора, $n$ означава број темена у насумичном графу $G$, а $k$ означава просечан степен. $P$ процесори су мапирани у дводимензионални логички процесорски низ, док $R$ и $C$ означавају траке редова и колона процесорског низа, респективно. Разматрни су само усмерени графови.

\subsection{Дистрибуирани \textit{BFS} алгоритам са једнодимензионим партиционисањем}
Једнодимензионо партиционисање графа подразумева расподелу темена графа, тако да сваки чвор и сви потези који произилазе из тог чвора припадају само једном прецесору \footnote{Претпоставља се да се један процес извршава на једном прецесору.\label{1p-1P}}. Скуп темена који припадају једном процесору $q$ ће даље бити називан скуп \textit{локалних темена}. У наставку је приказа илустрација једнодимензионог партиционисања темена графа на $P$ партиција коришћењем матрице суседства $A$, која је подељена тако да су локална темена за неки процесор $q$ континуална.

\[
\begin{bmatrix}
A_1 \\
\noindent\rule{0.2\linewidth}{0.5pt} \\
A_2 \\
\noindent\rule{0.2\linewidth}{0.5pt} \\
\vdots \\
\noindent\rule{0.2\linewidth}{0.5pt} \\
A_P \\
\end{bmatrix}
\]

\par
Индекси подматрица суседства $A_i$ представљају индикаторе процесора којима су додељене. Потези који произилазе од темена $v_ј$ формирају листу потега, која је представљена листом темена у оквиру $j$-ог реда матрице суседства $A$. Како би партиционисање било што балансираније, сваки процесор треба да добије приближно једнак број темена и потега који од тих темена произилазе. У оквиру исечка \ref{pseudocode:algorithm-bfs-distance-1D-par-pseudo} је дат псеудокод алгоритма за дистрибуирано претраживање графа са једнодимензионим партиционисањем, почевши од чвора $v_s$. У оквиру алгоритма, свако теме $v_i$ бива означено са својим нивоом, у оквиру низа $L_{v_s}(v_i)$, што означава растојање чвора $v_s$ од чвора $v_i$. Низ $L_{v_s}$ је дистрибуиран у складу са дистрибуцијом темена, тако да процесор $P_i$ поседује растојања почетног темена $v_s$ до својих локалних темена $\{ \; v_{(i, 0)}, v_{(i, 1)}, ..., v_{(i, m)} \; \}$ где је $m = \frac{|V|}{|P|}$.

\begin{figure}[!ht]
    \centering
    \input{kodovi/bfs-distance-1D-par-pseudo.tex}
    \caption{\textit{Псеудокод дистрибуираног BFS алгоритма са једнодимензионим партиционисањем}}
    \label{pseudocode:algorithm-bfs-distance-1D-par-pseudo}
\end{figure}

\par
Алгоритам функционише на следећи начин. На сваком нивоу (дубине графа), сваки од процесора има скуп $F$ који представља скуп локалних темена који се налазе на растојању \textit{level} од почетног чвора. Листа потега која се добија од сваког од темена из скупа $F$ бива унификована у скуп потега $N$ који представља скуп суседних темена. Поједина темена у оквиру скупа $N$ неће бити из скупа локалних темена који је додељен процесору. За ова темена, врши се размена са процесором $q$, коме се темена која њему припадају шаљу, а темена која припадају тренутном процесору примају од истог процесора $q$. Сваки од процесора врши ову размену темена и формира коначан скуп  $\widehat{N}$, скуп темена до којих се стигло у тренутном нивоу, а који су из скупа локалних темена за тренутни процесор. Могуће је да је процесор означио поједина темена из $\widehat{N}$ као посећена, што значи да их сада више неће разматрати.

\subsection{Дистрибуирани \textit{BFS} алгоритам са дводимензионим партиционисањем}
Дводимензионо партиционисање графа јесте партиционисање потега, тако да сваки потег припада тачно једном процесору. Поред тога, скуп темена графа је такође подељен, тако да свако теме припада само једном процесору \cite{bfs-dist}. Процесор складишти поједине потеге који су везани за његова локална темена, као и поједине потеге који нису везани за његова локална темена. Овакво партиционисање је приказано у оквиру матрице суседства $A$, која је организована тако да су темена које поседује један процесор суседна.

\[
\begin{bNiceArray} {c | c | c | c}
\qquad A_{1, 1}^{(1)} \qquad \ & \qquad A_{1, 2}^{(1)} \qquad \ & \qquad \hdots \qquad \ & \qquad A_{1, C}^{(1)} \qquad \ \\ \hline
A_{2, 1}^{(1)} & A_{2, 2}^{(1)} & \hdots & A_{2, C}^{(1)} \\ \hline
\vdots & \vdots & \ddots & \vdots \\ \hline
A_{R, 1}^{(1)} & A_{R, 2}^{(1)} & \hdots & A_{R, C}^{(1)} \\ \hline
\multicolumn{4}{c}{\vdots} \\
\multicolumn{4}{c}{\vdots} \\
\multicolumn{4}{c}{\vdots} \\ \hline
A_{1, 1}^{(C)} & A_{1, 2}^{(C)} & \hdots & A_{1, C}^{(C)} \\ \hline
A_{2, 1}^{(C)} & A_{2, 2}^{(C)} & \hdots & A_{2, C}^{(C)} \\ \hline
\vdots & \vdots & \ddots & \vdots \\ \hline
A_{R, 1}^{(C)} & A_{R, 2}^{(C)} & \hdots & A_{R, C}^{(C)}
\end{bNiceArray}
\]

\par
Овде, партиционисање је извршено за $P = R \cdot C$ процесора, који су логички организовани у матрицу процесора $R \times C$. Надаље ће се користити термини \textit{ред-процесора} и \textit{колона-процесора} како би се означиле подгрупе процесора у процесорској мрежи. У оквиру дводимензионог партиционисања, матрица суседства је подељена на $R \cdot C$ блокове редова и $C$ блокове колона. Нотација $A_{i, j}^{(*)}$ означава блок који припада процесору који у мрежи процесора има индексе $(i, j)$. Сваки од процесора има $C$ блокова. Како би се извршило партиционисање темена, процесор $P_{(i, j)}$ добија темена која одговарају блоку редова $(j - 1) \cdot R + i$. Како би партиционисање било избалансирано, сваки од процесора би требало да добије по једнак број темена и потега. Једнодимензионо партиционосање се може свести на случај дводимензионог партиционисања када је $R = 1$ или $C = 1$.

\par
За дводимензионо партиционисање, претпоставља се да је листа потега датог темена једна колона у оквиру матрице суседства. На основу тога, сваки блок у дводимензионом партиционисању садржи парцијалну листу суседа. Када се примени овакво партиционисање, сваки процесор има скуп $F$ који представља скуп локалних темена процесора $P_{(i,j)}$ који се налазе на нивоу \textit{level} у односу на почетно теме $v_s$. Посматрањем темена $v_i$ из скупа $F$, процесор власник овог темена шаље поруке осталим процесорима у својој колони процесора информацију да је стигао до чвора $v_i$, како би му они вратили листу потега која садржи ово теме. Оваква комуникација се назива операцијом \textit{експанзије (eng. expand)}. Парцијалне листе потега сваког од чворора се претражују како би се формирао скуп $N$ који представља скуп чворова за следећи ниво дубине. Темена из $N$ су даље разврстана тако да се деле у подскупове $N_q$ који се размењују са процесором $P_q$ у оквиру истог реда мреже процесора. Оваква комуникација се назива операцијом \textit{склапања (eng. fold)}. Предност дводимензионог партиционисања је то што процесорска комуникација у оквиру реда процесора и колоне процесора захтева $R$ и $C$ процесора, респективно, док је у једнодимензионом партиционисању при свакој комуникацији укључен сваки процесор. У оквиру алгоритма \ref{pseudocode:algorithm-bfs-distance-2D-par-pseudo}.

\begin{figure}[!ht]
    \centering
    \input{kodovi/bfs-distance-2D-par-pseudo.tex}
    \caption{\textit{Псеудокод дистрибуираног BFS алгоритма са дводимензионим партиционисањем}}
    \label{pseudocode:algorithm-bfs-distance-2D-par-pseudo}
\end{figure}

\par
У операције експанзије, процесори шаљу индексе граничних темена (локална темена која се налазе на тренутној дубини, односно на дубини $level$) осталим процесима. За густо поседнуте матрице, а у појединим случајима и за ретко поседнуте матрице), ова операција је традиционално имплементирана као $all-gather$ групна операција, с обзиром да сви индекси које поседује процесор морају бити послати. За секвенцијални $BFS$, ово је еквивалентно скупу граничних темена у глобалу. Ова операција нажалост није скалабилна када се повећава број процесора.

\par
За слабо повезане графове, веће перформансе би се добиле, уколико би се слала само темена која су гранична (на раздаљини $level$
од почетног темена $v_s$) и то да се шаљу само оним процесорима који имају непразну листу парцијалних потега која одговарају тим теменима. Ова операција може бити имплементирана као колективна $all-to-all$ операција или алтернативно као већи број позива $broadcast$ операције. У случају дводимензионог партиционисања, сваки процесор мора да складишти информацију у листи потега других процесора у оквиру своје колоне у процесорској мрежи. Меморија неопходна за ове податке је пропорцинална броју локалних темена процесора, те је и скалабилна.

\par
Операција склапања је традиционално имплементирана за густо поседнуте матрице, као $all-to-all$ комуникација. Алтернатива јесте да се имплементира операција склапања као операција $reduce-scatter$. У том случају, сваки процесор прима $\widehat{N}$ директно и линија 16 у алгоритму \ref{pseudocode:algorithm-bfs-distance-2D-par-pseudo} није неопходна. Операција редукције, која се јавља у фази редукције ове операције је операција уније скупа и елиминише дупликате.

\section{Паралелни \textit{BFS} алгоритам са дељеном меморијом}
У поређењу са паралелним \textit{BFS} алгоритмом са дистрибуираном меморијом, дељена меморија обезбеђује већи меморијски пропусни опсег и ниже кашњење. Пошто сви процесори заједно деле меморију, сви имају директан приступ њој. Дакле, нема потребе за интерпроцесну комуникацију, која је неопходна да би дистрибуирана меморија добила податке из удаљене локалне меморије. На овај начин се избегавају додатни трошкови размене порука \cite{bfs-par}.

\par
Међутим, показало се да су број темена у сваком новоу и број суседа сваког од темена веома неправилни, што доводи до веома неправилних приступа меморији и расподеле рада у \textit{BFS}-у. У паралелном \textit{BFS}-у, ова специфичност смањује предности паралелизације због неуравнотеженог оптерећења. Као резултат тога, веома је важно да паралелни \textit{BFS} на дељеној меморији буде избалансиран. Штавише, истраживање локације података такође може убрзати процес паралелизације \cite{bfs-par}.

\par
Многи паралелни \textit{BFS} алгоритми на дељеној меморији могу се поделити у два типа:
\begin{enumerate}
    \vspace{-5mm}
    \item Приступ усредсређен на контејнере \cite{bfs-par} и
    \item Приступ усредсређен на темена \cite{bfs-par}
\end{enumerate}
 
 \par
 У оквиру \textbf{приступа усредсређеним на контејнер}, креирају се две структуре података за складиштење тренутних граничних и следећих граничних темена. Скуп следећих граничних темена се пребацује на скуп тренутних граничних темена на последњем кораку сваке итерације. Постоји компромис између цене за синхронизацију и локације података према месту где се подаци чувају. Ове две структуре података могу се држати у сваком ентитету за обраду (као што је нит) који подржава локализацију података, али захтева додатне механизме за балансирање оптерећења. Алтернативно, они могу бити глобални како би обезбедили имплицитно балансирање оптерећења, где се специјалне структуре података користе за истовремени приступ ентитета за обраду. Али тада ће ти ентитети за обраду радити истовремено и потребно је више напора за синхронизацију.

\par
Поред тога, може се оптимизовати организација података контејнера. Типична структура података у серијском \textit{BFS}-у и неком паралелном \textit{BFS}-у је \textit{FIFO} ред \cite{fifo}, јер је једноставан и брз, с обзиром да операција уметања и брисања кошта само константно време.

\par
Друга алтернатива је структура вреће \cite{bag}. Операција уметања у врећу траје $\mathcal{O}(\log{n})$ времена у најгорем случају, док је потребно само константно амортизовано време које је брзо као и \textit{FIFO}. Штавише, уједињење двеју врећа траје $\mathcal{O}(\log{n})$ времена где је $n$ број елемената у мањој врећи. Операција раздвајања двеју врећа такође траје $\mathcal{O}(\log{n})$ времена. Уз помоћ структуре врећа, одређени број темена (према параметру грануларности) се чува у једној врећи и структура вреће постаје основни паралелни ентитет. Штавише, редуктор се може комбиновати са структуром вреће за паралелно уписивање темена и њихово ефикасно прелажење.

\par
\textbf{Приступ усредсређен на темена} третира теме као паралелни ентитет, што омогућава паралелну итерацију. Свако теме је додељено паралелном ентитету. Овај приступ усредсређен на темена може добро да функционише само ако је дубина графа веома мала. Дубина графа у \textit{BFS}-у је дефинисана као максимално растојање било ког темена у графу до изворног темена \cite{graphs2}. Према томе, приступ усредсређен на темена је веома погодан за \textit{GPU}-ове ако је свака нит мапирана на тачно једно теме.